package chapter4;

import org.junit.*;
import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class Chapter4 {

    @Test
    public void problem88() {
        /*
        Declaring a Java record: Write an application that exemplifies the creation of a Java record. Moreover, provide a short description of the artifacts generated by the compiler for a record behind the scenes.
         */
        Point point = new Point(1, 2);
        assert point.x() == 1;
    }

    @Test
    public void problem89() {
        /*
        Introducing the canonical and compact constructors for records: Explain the role of the built-in recordâ€™s canonical and compact constructors. Provide examples of when it makes sense to provide such explicit constructors.
         */
        Point point = new Point(1);
        assert point.y() == 3;

        try {
            Point point2 = new Point(-1);
            assert(false);
        } catch (IllegalArgumentException e) {
            assert(true);
        }
    }

    @Test
    public void problem90() {
        /*
        Adding more artifacts in a record: Provide a meaningful list of examples about adding explicit artifacts in Java records (for instance, adding instance methods, static artifacts, and so on).
         */
        Point point = new Point(1, 2);
        assert point.getStringValue().equals("This is a test");

        assert Point.getStringValueStatic().equals("This is a test static");

        assert Point.constantString.equals("This is a constant");

        System.out.println(point.hashCode());
    }

    @Test
    public void problem91() {
        /*
        Iterating what we cannot have in a record: Exemplify what we cannot have in a record (for instance, we cannot have explicit private fields) and explain why.
         */
    }

    @Test
    public void problem92() {
        /*
        Defining multiple constructors in a record: Exemplify several approaches for declaring multiple constructors in a record.
         */
        Point origin = Point.atOrigin();            // (0, 0)
        Point symmetricPoint = Point.symmetric(5); // (5, 5)
    }

    @Test
    public void problem93() {
        /*
        Implementing interfaces in records: Write a program that shows how to implement interfaces in records.
         */
        Point point = new Point(1,2);
        point.print();
    }

    @Test
    public void problem94() {
        /*
        Understanding record serialization: Explain in detail and exemplify how record serialization works behind the scenes.
         */
        record Person(String name, int age) implements Serializable {}

        // Create an instance
        Person person = new Person("John Doe", 30);

        // Serialize the instance
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.ser"))) {
            oos.writeObject(person);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Deserialize the instance
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.ser"))) {
            Person deserializedPerson = (Person) ois.readObject();
            System.out.println("Deserialized Record: " + deserializedPerson);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void problem95() {
        /*
        Invoking the canonical constructor via reflection: Write a program that exemplifies how to invoke, via reflection, the canonical constructor of a record.
         */
        try {
            Class<?> recordClass = Point.class;
            // Check if the class is indeed a record
            if (recordClass.isRecord()) {
                System.out.println("Class " + recordClass.getName() + " is a record.");

                // Get all declared constructors
                Constructor<?>[] constructors = recordClass.getDeclaredConstructors();

                // Print the constructors
                System.out.println("Available constructors:");
                Arrays.stream(constructors).forEach(System.out::println);

                // Find the canonical constructor
                Constructor<?> canonicalConstructor = constructors[0]; // Usually, the canonical constructor is the first one returned.
                System.out.println("Canonical constructor: " + canonicalConstructor);

                // Define arguments required for the canonical constructor
                Object[] argsForConstructor = {(Object) 25};

                // Invoke the constructor dynamically
                Object personInstance = canonicalConstructor.newInstance(argsForConstructor);

                // Output the created instance
                System.out.println("Created record instance via reflection: " + personInstance);
            } else {
                System.out.println("The provided class is not a record.");
            }
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException |
                 InvocationTargetException | SecurityException e) {
            System.err.println("An error occurred while invoking the canonical constructor: " + e.getMessage());
            e.printStackTrace();
        }
    }

    @Test
    public void problem96() {
        /*
        Using records in streams: Write several examples to highlight the usage of records for simplifying functional expressions relying on the Stream API.
         */
        record Item(String name, String category, double price) {}

        // List of items
        List<Item> items = List.of(
                new Item("Laptop", "Electronics", 999.99),
                new Item("Headphones", "Electronics", 199.99),
                new Item("Banana", "Groceries", 0.99),
                new Item("Apple", "Groceries", 1.49),
                new Item("Shirt", "Clothing", 49.99)
        );

        // Group items by category using Streams
        Map<String, List<Item>> itemsByCategory = items.stream()
                .collect(Collectors.groupingBy(Item::category));

        // Print the result
        itemsByCategory.forEach((category, itemsInCategory) -> {
            System.out.println("Category: " + category);
            itemsInCategory.forEach(System.out::println);
        });

    }

    static double calculateDistance(Point p1, Point p2) {
        return Math.sqrt(Math.pow(p2.x() - p1.x(), 2) + Math.pow(p2.y() - p1.y(), 2));
    }

    @Test
    public void problem97() {
        /*
        Introducing record patterns for instanceof: Write a bunch of examples that introduce record patterns for instanceof, including nested record patterns.
         */
        Object obj = new Point(10, 20);

        // Match and deconstruct the record using `instanceof`
        if (obj instanceof Point(int x, int y)) {
            System.out.println("Point coordinates: x=" + x + ", y=" + y);
        }

        Object obj1 = new Circle(new Point(5, 5), 10.0);
        if (obj1 instanceof Point(int x, int y)) {
            System.out.println("It's a Point: x=" + x + ", y=" + y);
        } else if (obj1 instanceof Circle(Point center, double radius)) {
            System.out.println("It's a Circle with center " + center + " and radius " + radius);
        } else {
            System.out.println("Unknown shape");
        }

        Shape shape = new Circle(new Point(5, 10), 15.0);

        String result = switch (shape) {
            case Point(int x, int y) -> "Point at (" + x + ", " + y + ")";
            case Circle(Point(int x, int y), double radius) ->
                    "Circle with center (" + x + ", " + y + ") and radius " + radius;
            default -> "Unknown shape";
        };

        System.out.println(result);

        Object shape1 = new Rectangle(new Point(0, 10), new Point(10, 0));

        // Match and deconstruct a nested record
        if (shape1 instanceof Rectangle(Point(int x1, int y1), Point(int x2, int y2))) {
            System.out.println("Rectangle corners: (" + x1 + ", " + y1 + ") to (" + x2 + ", " + y2 + ")");
        }

        Object obj2 = new Circle(new Point(3, 4), 10.0);

        // Match a Circle with a specific condition
        if (obj2 instanceof Circle(Point(int x, int y), double radius) && radius > 5) {
            System.out.println("Circle with large radius: center=(" + x + ", " + y + "), radius=" + radius);
        } else {
            System.out.println("Shape does not match the criteria.");
        }

        Shape shape2 = new StringShape("A custom shape description");

        if (shape2 instanceof Point(int x, int y)) {
            System.out.println("Point at (" + x + ", " + y + ")");
        } else if (shape2 instanceof Circle(Point center, double radius)) {
            System.out.println("Circle with center " + center + " and radius " + radius);
        } else if (shape2 instanceof StringShape(String description)) {
            System.out.println("StringShape description: " + description);
        } else {
            System.out.println("Unknown shape.");
        }

        Object obj3 = new Line(new Point(0, 0), new Point(3, 4));

        if (obj3 instanceof Line(Point(int x1, int y1), Point(int x2, int y2))) {
            Point start = new Point(x1, y1);
            Point end = new Point(x2, y2);
            double distance = calculateDistance(start, end);
            System.out.println("The distance between the points is " + distance);
        }
    }

    @Test
    public void problem98() {
        /*
        Introducing record patterns for switch: Write a bunch of examples that introduce record patterns for switch.
         */
        record Point(int x, int y) {}

        Point point = new Point(0, 0);

        // Using a switch with record patterns
        switch (point) {
            case Point(int x, int y) when x == 0 && y == 0-> System.out.println("Origin Point");
            case Point(int x, int y) -> System.out.println("Point at (" + x + ", " + y + ")");
        }

    }

    @Test
    public void problem99() {
        /*
        Tackling guarded record patterns: Write several snippets of code to exemplify guarded record patterns (guarded conditions based on the binding variables).
         */
        Point p = new Point(3, 3);

        switch (p) {
            case Point(int x, int y) when x == y ->
                    System.out.println("Point lies on the line y = x");
            case Point(int x, int y) when x > 0 && y > 0 ->
                    System.out.println("Point is in the first quadrant");
            case Point(int x, int y) ->
                    System.out.println("Point at (" + x + ", " + y + ")");
        }

        Rectangle rect = new Rectangle(new Point(0, 10), new Point(10, 0));

        switch (rect) {
            case Rectangle(Point(int x1, int y1), Point(int x2, int y2)) when x1 == 0 && y1 == 10 && x2 == 10 && y2 == 0 ->
                    System.out.println("Rectangle is exactly at (0,10) to (10,0)");
            case Rectangle(Point(int x1, int y1), Point(int x2, int y2)) when x1 < x2 && y1 > y2 ->
                    System.out.println("Rectangle spans top-left to bottom-right");
            default -> System.out.println("General rectangle");
        }

        Circle circle = new Circle(new Point(5, 5), 10.0);

        switch (circle) {
            case Circle(Point(int x, int y), double radius) when radius > 15 ->
                    System.out.println("Large circle centered at (" + x + ", " + y + ")");
            case Circle(Point(int x, int y), double radius) when x == y ->
                    System.out.println("Circle with center on the line y = x");
            case Circle(Point(int x, int y), double radius) ->
                    System.out.println("Circle centered at (" + x + ", " + y + ") with radius " + radius);
        }

        Point point = new Point(4, -2);

        if (point instanceof Point(int x, int y) && x > 0 && y > 0) {
            System.out.println("Point is in the first quadrant");
        } else if (point instanceof Point(int x, int y) && x < 0 && y > 0) {
            System.out.println("Point is in the second quadrant");
        } else if (point instanceof Point(int x, int y) && x < 0 && y < 0) {
            System.out.println("Point is in the third quadrant");
        } else if (point instanceof Point(int x, int y) && x > 0 && y < 0) {
            System.out.println("Point is in the fourth quadrant");
        } else {
            System.out.println("Point lies on an axis");
        }

        Shape shape = new Circle(new Point(0, 0), 12.0);

        switch (shape) {
            case Circle(Point(int x, int y), double radius) when radius >= 10 ->
                    System.out.println("Large circle centered at (" + x + ", " + y + ")");
            case Circle(Point(int x, int y), double radius) ->
                    System.out.println("Small circle centered at (" + x + ", " + y + ")");
            case Rectangle(Point topLeft, Point bottomRight) ->
                    System.out.println("Rectangle from " + topLeft + " to " + bottomRight);
            default -> System.out.println("Unknown shape");
        }

    }

    // Generic method to process a pair
    static <T, U> void printPairDetails(Pair<T, U> pair) {
        System.out.println("First: " + pair.first() + ", Second: " + pair.second());
    }

    @Test
    public void problem100() {
        /*
        Using generic records in record patterns: Write an application that highlights the declaration and usage of generic records.
         */

        // Example 1: Using Pair with Integer values
        Pair<Integer, Integer> point = new Pair<>(10, 20);
        System.out.println("Point coordinates: " + point.first() + ", " + point.second());

        // Example 2: Using Pair with String values
        Pair<String, String> name = new Pair<>("John", "Doe");
        System.out.println("Full name: " + name.first() + " " + name.second());

        // Example 3: Using Pair with mixed types
        Pair<String, Integer> item = new Pair<>("Apples", 5);
        System.out.println("Item: " + item.first() + ", Quantity: " + item.second());

        // Example 4: Using Pair to store related types
        Pair<Pair<Integer, Integer>, Pair<Integer, Integer>> rectangle =
                new Pair<>(new Pair<>(0, 0), new Pair<>(10, 10));
        System.out.println("Rectangle corners: " +
                "Bottom-left: " + rectangle.first() +
                ", Top-right: " + rectangle.second());

        // Example 5: Generic processing of a Pair (utility method)
        printPairDetails(point);
        printPairDetails(name);
        printPairDetails(item);

    }

    @Test
    public void problem101() {
        /*
        Handling nulls in nested record patterns: Explain and exemplify how to deal with null values in record patterns (explain the edge case of null values in nested record patterns as well).
         */
        Point point = null; // Simulate a null Point

        switch (point) {
            case null -> System.out.println("Point is null");
            case Point(int x, int y) -> System.out.println("Point: (" + x + ", " + y + ")");
        }

        Rectangle rectangle = new Rectangle(null, new Point(10, 10)); // Simulate a nested null

        switch (rectangle) {
//            case Rectangle(Point(int x1, int y1), null) ->
//                    System.out.println("Top-left corner is null, but bottom-right: (" + x2 + ", " + y2 + ")");
            case Rectangle(Point(int x1, int y1), Point(int x2, int y2)) ->
                    System.out.println("Rectangle corners: Top-left: (" + x1 + ", " + y1 + "), Bottom-right: (" + x2 + ", " + y2 + ")");
            default ->
                    System.out.println("Unexpected rectangle state");
        }
    }

    // Method to evaluate the expression using record patterns
    public static int evaluate(Expr expr) {
        return switch (expr) {
            case Constant(int value) -> value; // Base case: constant value
/*            case BinaryOp("+", Expr left, Expr right) -> evaluate(left) + evaluate(right);
            case BinaryOp("-", Expr left, Expr right) -> evaluate(left) - evaluate(right);
            case BinaryOp("*", Expr left, Expr right) -> evaluate(left) * evaluate(right);
            case BinaryOp("/", Expr left, Expr right) -> {
                int denominator = evaluate(right);
                if (denominator == 0) throw new ArithmeticException("Division by zero");
                yield evaluate(left) / denominator;
            }
            case UnaryOp("-", Expr operand) -> -evaluate(operand); */
            default -> throw new IllegalStateException("Unexpected expression: " + expr);
        };
    }

    // Method to simplify the expression using record patterns
    public static Expr simplify(Expr expr) {
        return switch (expr) {
            case Constant(int value) -> expr; // Constant is already simplified
/*            case UnaryOp("-", Constant(int value)) -> new Constant(-value); // Simplify unary negation on a constant
            case UnaryOp(String operator, Expr operand) -> new UnaryOp(operator, simplify(operand)); // Simplify operand(s)
            case BinaryOp("+", Constant(0), Expr right) -> simplify(right); // Add 0 -> simplify to the right operand
            case BinaryOp("+", Expr left, Constant(0)) -> simplify(left);  // Add 0 -> simplify to the left operand
            case BinaryOp("*", Constant(1), Expr right) -> simplify(right); // Multiply by 1 -> simplify to the right operand
            case BinaryOp("*", Expr left, Constant(1)) -> simplify(left);  // Multiply by 1 -> simplify to the left operand
            case BinaryOp("*", Constant(0), Expr right) -> new Constant(0); // Multiply by 0 -> result is 0
            case BinaryOp("*", Expr left, Constant(0)) -> new Constant(0);  // Multiply by 0 -> result is 0
            case BinaryOp(String operator, Expr left, Expr right) ->
                    new BinaryOp(operator, simplify(left), simplify(right)); // Simplify both sides of the operation */
            default -> expr; // If nothing matches, return as is
        };
    }

    @Test
    public void problem102() {
        /*
        Simplifying expressions via record patterns: Imagine that you have an expression (arithmetic, string-based, Abstract Syntax Tree (AST), and so on). Write a program that uses record patterns to simplify the code for evaluating/transforming this expression.
         */
// Build an example AST for the expression: (5 + -3) * 2
        Expr expression = new BinaryOp("*",
                new BinaryOp("+",
                        new Constant(5),
                        new UnaryOp("-", new Constant(3))
                ),
                new Constant(2)
        );

        // Evaluate the expression
        int result = evaluate(expression);
        System.out.println("Evaluation result: " + result);

        // Transform the expression (e.g., simplify constants)
        Expr simplified = simplify(expression);
        System.out.println("Simplified expression: " + simplified);

        // Evaluate again for the simplified expression
        System.out.println("Re-evaluated result: " + evaluate(simplified));


    }

    @Test
    public void problem103() {
        /*
        Hooking unnamed patterns and variables: Explain and exemplify the JDK 21 preview feature covering unnamed patterns and variables.
         */
        record Order(int id, double amount, String status) {}

        Order order = new Order(123, 250.5, "SHIPPED");

        switch (order) {
            // Only interested in checking the status
//            case Order(_, _, "SHIPPED") -> System.out.println("Order has been shipped!");
//            case Order(_, _, "PENDING") -> System.out.println("Order is still pending.");
            default -> System.out.println("Unhandled order status.");
        }

        Point point = new Point(10, 20);
        // Using an unnamed variable to ignore the 'x' coordinate
        if (point instanceof Point(_, int y)) {
            System.out.println("Y coordinate is: " + y);
        }

        // Example with local variable declaration
        var order1 = new Order(101, 300.0, "John Doe");
//        var (_, customer, _) = order1; // Ignore id and total, only use customer
//        System.out.println("Customer: " + customer);


    }

    @Test
    public void problem104() {
        /*
        Tackling records in Spring Boot: Write several applications for exemplifying different use cases of records in Spring Boot (for instance, using records in templates, using records for configurations, and so on).
         */
    }

    @Test
    public void problem105() {
        /*
        Tackling records in JPA: Write several applications for exemplifying different use cases of records in JPA (for instance, using records and constructor expressions, using records and result transformers, and so on).
         */
    }

    @Test
    public void problem106() {
        /*
        Tacking records in jOOQ: Write several applications for exemplifying different use cases of records in jOOQ (for instance, using records and the MULTISET operator).
         */
    }
}
