package chapter5;

import org.junit.*;

public class Chapter5 {

    @Test
    public void problem107() {
        /*
         Introducing parallel computations with arrays: Explain in a few paragraphs what data parallel processing is and how it works.
        */
    }

    @Test
    public void problem108() {
        /*
        Covering the Vector APIâ€™s structure and terminology: Explain with examples the Vector API terminology. Cover notions such as element type, shape, species, lanes, and so on.
         */
    }

    @Test
    public void problem109() {
        /*
        Summing two arrays via the Vector API: Write an application that uses the Vector API for summing up two Java arrays.
         */
    }

    @Test
    public void problem110() {
        /*
        Summing two arrays unrolled via the Vector API: Write an application that uses the Vector API for summing two Java arrays using the unrolled technique.
         */
    }

    @Test
    public void problem111() {
        /*
        Benchmarking the Vector API: Given two arrays, x[] and y[], write an application that benchmarks the computation z[] = x[] + y[], w[] = x[] * z[] * y[], k[] = z[] + w[] * y[] using plain Java and the Vector API.
         */
    }

    @Test
    public void problem112() {
        /*
        Applying the Vector API to compute FMA: Provide a Vector API implementation of the famous Fused Multiply Add (FMA).
         */
    }

    @Test
    public void problem113() {
        /*
        Multiplying matrices via the Vector API: Write a Vector API implementation for multiplying two matrices.
         */
    }

    @Test
    public void problem114() {
        /*
        Hooking the image negative filter with the Vector API: Write a program that uses the Vector API to apply the negative filter to an image.
         */
    }

    @Test
    public void problem115() {
        /*
        Dissecting factory methods for collections: Exemplify several approaches for creating unmodifiable/immutable maps, lists, and sets in Java.
         */
    }

    @Test
    public void problem116() {
        /*
        Getting a list from a stream: Provide several snippets of code useful for collecting Stream content into a Java List.
         */
    }

    @Test
    public void problem117() {
        /*
        Handling map capacity: Explain what the capacity of a Java Map is and how it can be used to control the number of effective mappings.
         */
    }

    @Test
    public void problem118() {
        /*
        Tackling Sequenced Collections: Provide in-depth dive into the JDK 21 Sequenced Collections API. Exemplify this API on your favorite Java collections and explain what the alternatives before this API are.
         */
    }

    @Test
    public void problem119() {
        /*
        Introducing the Rope data structure: Explain what the Rope data structure is and provide a Java implementation for its main operations (index, insert, delete, concatenation, and split).
         */
    }

    @Test
    public void problem120() {
        /*
        Introducing the Skip List data structure: Explain and exemplify the Skip List data structure.
         */
    }

    @Test
    public void problem121() {
        /*
        Introducing the K-D Tree data structure: Provide a brief introduction of K-D Trees and a Java implementation for 2-D Trees.
         */
    }

    @Test
    public void problem122() {
        /*
        Introducing the Zipper data structure: Explain and exemplify on a tree the Zipper data structure.
         */
    }

    @Test
    public void problem123() {
        /*
        Introducing the Binomial Heap data structure: Provide a deep coverage of a Binomial Heap data structure. Explain its main operations and exemplify them in a Java implementation.
         */
    }

    @Test
    public void problem124() {
        /*
        Introducing the Fibonacci Heap data structure: Explain and exemplify the Fibonacci Heap data structure.
         */
    }

    @Test
    public void problem125() {
        /*
        Introducing the Pairing Heap data structure: Explain and exemplify the Pairing Heap data structure.
         */
    }

    @Test
    public void problem126() {
        /*
        Introducing the Huffman Coding data structure: The Huffman Coding algorithm was developed by David A. Huffman in 1950. Explain its usage and exemplify it via a Java implementation.
         */
    }

    @Test
    public void problem127() {
        /*
        Introducing the Splay Tree data structure: A Splay Tree is a flavor of Binary Search Tree (BST). Explain what its particularities are and provide an implementation of its main operations.
         */
    }

    @Test
    public void problem128() {
        /*
        Introducing the Interval Tree data structure: An Interval Tree is another flavor of Binary Search Tree (BST). Highlight its usage and exemplify it via a Java implementation.
         */
    }

    @Test
    public void problem129() {
        /*
        Introducing the Unrolled Linked List data structure: Explain and exemplify the Unrolled Linked List data structure.
         */
    }

    @Test
    public void problem130() {
        /*
        Implementing join algorithms: There are three famous join algorithms: Nested Loop Join, Hash Join, and Sort Merge Join. Explain and exemplify each of them in two tables that are involved in a one-to-many relationship.
         */
    }
}
